syntax = "proto3";

package ai.pipestream.tourney.unary.v1;

option java_package = "ai.pipestream.tourney.unary.v1";
option java_multiple_files = true;
option go_package = "github.com/ai-pipestream/paper-rock-scissors/clients/go/pb/ai/pipestream/tourney/unary/v1;unaryv1";

// The "Heavy" Service: Stateless and Database-Dependent
service UnaryArenaService {
  // Step 1: Client registers to play. Returns a match_id.
  rpc Register (RegisterRequest) returns (RegisterResponse);

  // Step 2: Client submits a move. 
  // The Server will likely return "WAITING" if the opponent hasn't moved.
  rpc SubmitMove (SubmitMoveRequest) returns (SubmitMoveResponse);

  // Step 3: Client must POLL this repeatedly to see if they won the round.
  // This is the "Latency Tax."
  rpc CheckRoundResult (CheckRoundResultRequest) returns (CheckRoundResultResponse);
}

message RegisterRequest {
  string language_name = 1; // e.g., "Java-21", "Python-3.11"
  string prng_algorithm = 2; // e.g., "L64X128MixRandom"
}

message RegisterResponse {
  string match_id = 1;      // The "Context Key"
  string opponent_name = 2;
  string status = 3;        // "WAITING_FOR_OPPONENT" or "READY"
}

message SubmitMoveRequest {
  string match_id = 1;      // REQUIRED: Context lookup
  int32 round_number = 2;   // REQUIRED: State sync
  int32 move = 3;           // 0=Rock, 1=Paper, 2=Scissors
}

message SubmitMoveResponse {
  string status = 1;        // "ACCEPTED", "INVALID_TURN", "GAME_OVER"
}

message CheckRoundResultRequest {
  string match_id = 1;
  int32 round_number = 2;
}

message CheckRoundResultResponse {
  string status = 1;        // "PENDING", "COMPLETE"
  int32 opponent_move = 2;  
  string outcome = 3;       // "WIN", "LOSS", "TIE"
}
